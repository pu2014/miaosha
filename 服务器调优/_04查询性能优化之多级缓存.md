## 查询性能优化之多级缓存
设计原则:
1. 快速存取设备，用内存
2. 将缓存推到离用户最近的地方
3. 脏缓存处理

### redis缓存 -- nosql
   
```
public ReturnType getItem(@RequestParam(name="id")Integer id){
        //根据商品的id去redis获取
        ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get("item_" + id);

        //不存在就访问下游service
        if(itemModel == null){
            itemModel = itemService.getItemById(id);

            //存储
            redisTemplate.opsForValue().set("item_" + id, itemModel);
            redisTemplate.expire("item_" + id, 10, TimeUnit.MINUTES);
        }
        return ReturnType.create(convertViewFromModel(itemModel));
    }
```
>注意：注意序列化和反序列化存储数据。

### 本地热点数据缓存
设计：
1. 热点数据
2. 脏读不敏感
3. 内存可控
设计：一个hashmap 但线程不安全
        ConcurrentHashmap 段的加锁，影响性能

##### Guava cache 
1. 可控制的大小和超时时间
2. 可配置的lru策略
3. 线程安全

采用多级缓存：
```
ItemModel itemModel = null;
        //先去本地缓存
        itemModel = (ItemModel) cacheService.getFromCommonCache("item_" + id);

        if(itemModel == null) {
            //根据商品的id去redis获取
            itemModel = (ItemModel) redisTemplate.opsForValue().get("item_" + id);

            //不存在就访问下游service
            if (itemModel == null) {
                itemModel = itemService.getItemById(id);
                //存储到redis
                redisTemplate.opsForValue().set("item_" + id, itemModel);
                redisTemplate.expire("item_" + id, 10, TimeUnit.MINUTES);
            }
            cacheService.setCommonCache("item_" + id, itemModel);
        }
```
 